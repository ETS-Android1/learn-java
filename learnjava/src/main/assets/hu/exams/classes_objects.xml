<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!-- Exam of OOP and classes --><resources>
    <examdata>
        <id>15</id>
        <questionAmount>25</questionAmount>
        <timeLimit>30</timeLimit>
        <finished>true</finished>
    </examdata>

    <!-- Questions for creating classes -->
    <question type="text">
        <text>Mit jelent az OOP?</text>
        <correct>Objektum-orientált programozás</correct>
		<correct>Objektum orientált programozás</correct>
		<correct>Object oriented programming</correct>
        <ignoreCase/>
    </question>
    <question type="single_choice">
        <text>Mi az az osztály?</text>
        <answer>Az objektum másik neve.</answer>
        <answer>Egy adattípus viselkedéssel, és egy "tervrajz" az objektumok számára.</answer>
        <answer>Egy fájl, amely Java forráskódot tartalmaz.</answer>
        <answer>Egy fájl, amely Java bytecode-ot tartalmaz.</answer>
        <correct>1</correct>
    </question>
    <question type="single_choice">
        <text>Mi az objektum?</text>
        <answer>Egy 'tervrajz' az osztályok létrehozásához.</answer>
        <answer>Az osztály másik neve.</answer>
        <answer>Egy példányosított osztály.</answer>
        <correct>2</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszót használjuk egy osztály létrehozására?</text>
        <correct>class</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszóval hozhatunk létre objektumokat?</text>
        <correct>new</correct>
    </question>
    <question type="true_false">
        <text>Az osztály meghatározza a belőle létrehozható objektumok struktúráját.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Létezik egy 'custom' nevű objektumunk, amelynek van egy 'getValue' metódusa. Hogyan hívjuk meg ezt a metódust?</text>
        <correct>custom.getValue()</correct>
        <correct>custom.getValue();</correct>
    </question>
    <question type="text">
        <text>Létezik egy 'handler' nevű objektumunk, amelynek van egy 'value' tagja. Hogyan hivatkozhatunk erre a változóra?</text>
        <correct>handler.value</correct>
        <correct>handler.value;</correct>
    </question>
    <question type="multi_choice">
        <text>Melyik osztály tartalmazhat ezek közül?</text>
        <answer>Metódusok.</answer>
        <answer>Csomagok.</answer>
        <answer>Tagváltozók.</answer>
        <correct>0</correct>
        <correct>2</correct>
    </question>
    <question type="true_false">
        <text>Az osztálytagok alapértelmezett értékeikkel inicializálódnak.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszóval hivatkozhatunk az osztály metódusaiban az aktuális objektumra?</text>
        <correct>this</correct>
    </question>

    <!-- Questions for Encapsulation, overloading and constructors -->
    <question type="single_choice">
        <text>Mi a túlterhelés (overload)?</text>
        <answer>Több azonos nevű osztály létrehozása.</answer>
        <answer>Több azonos nevű csomag létrehozása..</answer>
        <answer>Több azonos nevű tagváltozó létrehozása.</answer>
        <answer>Több azonos nevű metódus létrehozása.</answer>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Hogyan különbözteti meg a Java az overload-olt metódusokat?</text>
        <answer>A nevük alapján.</answer>
        <answer>A paramétereik alapján.</answer>
        <answer>Ezeket csak véletlenszerűen hívja meg.</answer>
        <answer>A visszatérési típus szerint.</answer>
        <correct>1</correct>
    </question>
    <question type="true_false">
        <text>Az overload-olt metódusoknak különböző visszatérési típusokkal kell rendelkezniük.</text>
        <correct>false</correct>
    </question>
    <question type="true_false">
        <text>A overload-olt metódusok különböző visszatérési típusokkal rendelkezhetnek.</text>
        <correct>true</correct>
    </question>
    <question type="true_false">
        <text>A overload-olt metódusoknak különböző paraméterekkel kell rendelkezniük.</text>
        <correct>true</correct>
    </question>
    <question type="multi_choice">
        <text>Melyek igazak a konstruktorokra?</text>
        <answer>Új objektumokat hoznak létre.</answer>
        <answer>Nem lehet őket túlterhelni (overload-olni).</answer>
        <answer>A nevüknek 'Konstruktor'-nak kell lennie.</answer>
        <answer>A new kulcsszóval hívjuk meg őket.</answer>
        <correct>0</correct>
        <correct>3</correct>
    </question>
    <question type="true_false">
        <text>Az alapértelmezett konstruktor mindig létrejön.</text>
        <correct>false</correct>
    </question>
    <question type="text">
        <text>Hány paramétere van az alapértelmezett konstruktornak?</text>
        <correct>0</correct>
        <correct>zero</correct>
		<correct>nulla</correct>
		<ignoreCase/>
    </question>
    <question type="text">
        <text>Van egy 'Complex' nevű osztályunk. Mi kill, hogy legyen a konstruktorok neve?</text>
        <correct>Complex</correct>
    </question>
    <question type="multi_choice">
        <text>Melyek ezek közül a Java-ban érvényes láthatóságok?</text>
        <answer>public</answer>
        <answer>hidden</answer>
        <answer>protected</answer>
        <answer>portable</answer>
        <correct>0</correct>
        <correct>2</correct>
    </question>
    <question type="single_choice">
        <text>Mi az egységbe zárás?</text>
        <answer>Az az elv, hogy minden osztályt egy csomagba rejtünk el.</answer>
        <answer>Ez egy másik neve a túlterhelésnek (overload-nak).</answer>
        <answer>Az osztály "implementációjának" elrejtésének elve.</answer>
        <correct>2</correct>
    </question>
    <question type="text">
        <text>Hány láthatósági típus van a Java-ban?</text>
        <correct>4</correct>
        <correct>four</correct>
		<correct>négy</correct>
		<ignoreCase/>
	</question>
    <question type="single_choice">
        <text>Melyik láthatósági típus a legszigorúbb (vagyis az ezzel jelölt részek a legkevesebb helyen láthatók)?</text>
        <answer>public</answer>
        <answer>default</answer>
        <answer>private</answer>
        <answer>protected</answer>
        <correct>2</correct>
    </question>
    <question type="single_choice">
        <text>Melyik láthatóságot használjuk, ha azt szeretnénk, hogy valami csak a saját csomagjában legyen látható?</text>
        <answer>public</answer>
        <answer>private</answer>
        <answer>protected</answer>
        <answer>default</answer>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Melyik láthatóságot használjuk, ha azt szeretnénk, hogy valami mindenhol látható legyen?</text>
        <answer>public</answer>
        <answer>private</answer>
        <answer>protected</answer>
        <answer>default</answer>
        <correct>0</correct>
    </question>
    <question type="single_choice">
        <text>Melyik láthatóságot használjuk, ha biztosítani akarjuk, hogy valami látható legyen az alosztályokon belül?</text>
        <answer>public</answer>
        <answer>protected</answer>
        <answer>default</answer>
        <answer>private</answer>
        <correct>1</correct>
    </question>
    <question type="multi_choice">
        <text>Milyen láthatóságok használhatók az osztályokon is?</text>
        <answer>public</answer>
        <answer>private</answer>
        <answer>protected</answer>
        <answer>package-private</answer>
        <correct>0</correct>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Mi az a setter?</text>
        <answer>Egy osztály, amely értékeket rendel a változókhoz.</answer>
        <answer>Egy metódus, amely értéket rendel egy taghoz.</answer>
        <answer>Egy metódus, amely visszaadja egy rejtett tag értékét.</answer>
        <correct>1</correct>
    </question>

    <!-- Questions about inheritance -->
    <question type="single_choice">
        <text>Mi a (dinamikus) polimorfizmus?</text>
        <answer>Minden metódusnak lehet ugyanaz a neve.</answer>
        <answer>Egy objektum úgy viselkedhet, mint bármelyik osztály, amely az öröklési hierarchiában fölötte áll (szuperosztály).</answer>
        <answer>Több osztálynak is lehet ugyanaz a neve.</answer>
        <answer>Egy objektum úgy viselkedhet, mint bármelyik osztály, amely az öröklési hierarchiában alatta áll (alosztály).</answer>
        <correct>1</correct>
    </question>
    <question type="multi_choice">
        <text>Ezek közül melyeket örökli meg az alosztály a szülő osztályától?</text>
        <answer>public metódusok</answer>
        <answer>protected metódusok</answer>
        <answer>public adattagok</answer>
        <answer>private adattagok</answer>
        <correct>0</correct>
        <correct>1</correct>
        <correct>2</correct>
        <correct>3</correct>
    </question>
    <question type="true_false">
        <text>Egy osztálynak több alosztálya is lehet.</text>
        <correct>true</correct>
    </question>
    <question type="true_false">
        <text>Egy osztálynak több szülő osztálya is lehet.</text>
        <correct>false</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszót használjuk az osztályok közötti öröklődés megadására?</text>
        <correct>extends</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszóval tiltható le az osztályból történő öröklődés?</text>
        <correct>final</correct>
    </question>
    <question type="single_choice">
        <text>Mi a felülírás (override)?</text>
        <answer>Egy azonos nevű alosztály létrehozása.</answer>
        <answer>Egy tag újradefiniálása egy alosztályban.</answer>
        <answer>Metódus újradefiniálása egy alosztályban.</answer>
        <answer>A metódus túlterhelésének egy másik neve.</answer>
        <correct>2</correct>
    </question>
    <question type="text">
        <text>Melyik osztály áll az öröklési hierarchia tetején?</text>
        <correct>Object</correct>
        <correct>java.lang.Object</correct>
    </question>
    <question type="true_false">
        <text>Lehetőség van arra, hogy egy metódus ne legyen felülírható.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszóval hívjuk meg a szuperosztály konstruktorát (vagy egy metódusát)?</text>
        <correct>super</correct>
    </question>
    <question type="true_false">
        <text>A szülő osztály konstruktorának hívása az alosztály konstruktorának utolsó utasítása kell, hogy legyen.</text>
        <correct>false</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszót használjuk egy objektum típusának ellenőrzésére?</text>
        <correct>instanceof</correct>
    </question>
    <question type="true_false">
        <text>A felfelé átalakítás (upcast) biztonságos.</text>
        <correct>true</correct>
    </question>
    <question type="true_false">
        <text>A lefelé átalakítás (downcast) biztonságos.</text>
        <correct>false</correct>
    </question>
    <question type="single_choice">
        <text>Mi a cast-olás?</text>
        <answer>Az objektum típusának megváltoztatása.</answer>
        <answer>Egy metódus újradefiniálása egy alosztályban.</answer>
        <answer>Egy osztályban több azonos nevű metódus létrehozása.</answer>
        <answer>Egy osztály több alosztályának létezése.</answer>
        <correct>0</correct>
    </question>

    <!-- Questions about static and enum -->
    <question type="text">
        <text>Melyik kulcsszóval lehet egy tagot egy osztály összes objektuma között megosztottá tenni?</text>
        <correct>static</correct>
    </question>
    <question type="true_false">
        <text>A statikus tagok is lehetnek konstansok is.</text>
        <correct>true</correct>
    </question>
    <question type="single_choice">
        <text>Hogyan lehet egy statikus metódust hívni?</text>
        <answer>A hozzá tartozó objektum és a pont operátor használatával.</answer>
        <answer>Nem hívhatók.</answer>
        <answer>Az osztály, amelyhez tartozik, és az '==' operátor használatával.</answer>
        <answer>Az osztály, amelyhez tartozik, és a pont operátor használatával.</answer>
        <correct>3</correct>
    </question>
    <question type="multi_choice">
        <text>Melyik jelölhető statikusnak?</text>
        <answer>A tagok.</answer>
        <answer>Az osztályok.</answer>
        <answer>A metódusok.</answer>
        <answer>A lokális változók.</answer>
        <correct>0</correct>
        <correct>2</correct>
    </question>
    <question type="multi_choice">
       <text>Melyik jelölhető konstansnak?</text>
        <answer>A tagok.</answer>
        <answer>Az osztályok.</answer>
        <answer>A metódusok.</answer>
        <answer>A lokális változók.</answer>
        <correct>0</correct>
        <correct>1</correct>
        <correct>3</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszót használjuk egy enum deklarálására?</text>
        <correct>enum</correct>
    </question>
    <question type="multi_choice">
        <text>Hogyan hozhatunk létre konstansokat?</text>
        <answer>A final kulcsszó használatával.</answer>
        <answer>A static kulcsszó használatával.</answer>
        <answer>Konstansokat nem lehet létrehozni, minden változónak lehet újra értéket adni.</answer>
        <answer>Az enumok használatával.</answer>
        <correct>0</correct>
        <correct>3</correct>
    </question>
    <question type="true_false">
        <text>A konstans változókat és tagokat mindig az őket deklaráló utasításban kell hozzárendelni.</text>
        <correct>false</correct>
    </question>
    <question type="single_choice">
        <text>Melyik egy konstans correct elnevezése, Java-s szokások szerint?</text>
        <answer>SpeedOfLight</answer>
        <answer>SPEED_OF_LIGHT</answer>
        <answer>speedoflight</answer>
        <answer>speedOfLight</answer>
        <correct>1</correct>
    </question>
    <question type="true_false">
        <text>Az enum értékek biztonságosan összehasonlíthatók az '==' operátorral.</text>
        <correct>true</correct>
    </question>
    <question type="single_choice">
        <text>Mik az enum-ok?</text>
        <answer>Azok az osztályok, amelyekből nem lehet származtatni.</answer>
        <answer>Konstansnak és statikusnak jelölt változók.</answer>
        <answer>Kizárólag statikus tagokkal és metódusokkal rendelkező osztályok.</answer>
        <answer>Speciális osztályok, amelyek csak konstansokat tartalmaznak.</answer>
        <correct>3</correct>
    </question>

    <!-- Abstract classes and interfaces -->
    <question type="single_choice">
        <text>Mi az absztrakt osztály?</text>
        <answer>Egy osztály, amelynek nincsenek tagjai, csak metódusai.</answer>
        <answer>Egy olyan osztály, amely még nincs teljesen leprogramozva.</answer>
        <answer>Egy osztály, amelyet nem lehet példányosítani.</answer>
        <correct>2</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszó jelzi, hogy egy metódusnak nincs implementációja?</text>
        <correct>abstract</correct>
    </question>
    <question type="multi_choice">
        <text>Melyik jelölhető meg ezek közül absztraktnak?</text>
        <answer>Osztályok.</answer>
        <answer>Metódusok.</answer>
        <answer>Adattagok.</answer>
        <answer>Csomagok.</answer>
        <correct>0</correct>
        <correct>1</correct>
    </question>
    <question type="true_false">
        <text>Az absztrakt osztályoknak nem lehet konstruktora.</text>
        <correct>false</correct>
    </question>
    <question type="single_choice">
        <text>Mi az interfész?</text>
        <answer>Egy teljesen absztrakt osztály ("Java 8 előtt").</answer>
        <answer>Egy osztály, amely csak metódusokkal rendelkezik, tagok nélkül.</answer>
        <answer>Az absztrakt osztály másik neve.</answer>
        <answer>Egy osztály, amely nem tartalmaz konstruktorokat.</answer>
        <correct>0</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszót használjuk egy teljesen absztrakt "osztály" deklarálására?</text>
        <correct>interface</correct>
    </question>
    <question type="single_choice">
        <text>Ha egy osztály megvalósít egy interfészt, mit kell tennie a metódusaival?</text>
        <answer>Nem kell velük semmit sem csinálni.</answer>
        <answer>Meg kell őket valósítani, különben nem tudjuk az osztályt példányosítani.</answer>
        <answer>Ezek a metódusok törlésre kerülnek.</answer>
        <correct>1</correct>
    </question>
    <question type="multi_choice">
        <text>Mi a célja az interfészeknek?</text>
        <answer>Egy osztályt arra kényszeríteni, hogy egy sémát kövessen egy metódusok megvalósításával.</answer>
        <answer>Kevesebbet kell gépelni azáltal, hogy nem adunk implementációt a metódusainknak.</answer>
        <answer>Az, hogy objektumokat hozzunk létre belőlük.</answer>
        <answer>A több szuperosztályból való öröklődés szimulálása.</answer>
        <correct>0</correct>
        <correct>3</correct>
    </question>

    <!-- Questions about exception handling -->
    <question type="multi_choice">
        <text>Melyek ezek közül a Throwable alosztályai?</text>
        <answer>Integer</answer>
        <answer>Exception</answer>
        <answer>Error</answer>
        <answer>RuntimeException</answer>
        <correct>1</correct>
        <correct>2</correct>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Ezek közül melyik jelez súlyosabb problémát?</text>
        <answer>Hiba.</answer>
        <answer>Kivétel.</answer>
        <correct>0</correct>
    </question>
    <question type="true_false">
        <text>Az összes nem ellenőrzött kivétel szülő osztálya a RuntimeException.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszóval lehet kivételt kiváltani?</text>
        <correct>throw</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszót használjuk annak deklarálására, hogy egy metódus kivételt produkálhat?</text>
        <correct>throws</correct>
    </question>
    <question type="single_choice">
        <text>Ezek közül melyiket használják a kivételek kezelésére?</text>
        <answer>Az else-if blokkot.</answer>
        <answer>A while ciklust.</answer>
        <answer>A for ciklust.</answer>
        <answer>A try-catch blokkot.</answer>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Hogyan hozhatunk létre egyéni, nem ellenőrzött kivételeket?</text>
        <answer>Az Exception osztályból származtatással.</answer>
        <answer>Az Error osztályból származtatással.</answer>
        <answer>Egyéni kivételeket nem lehet létrehozni.</answer>
        <answer>A RuntimeException osztályból származtatással.</answer>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Mi az ellenőrzött kivétel?</text>
        <answer>Egy olyan kivétel, amelyet a programozó kénytelen kezelni.</answer>
        <answer>Egy try-catch blokkal körülvett kivétel</answer>.
        <answer>Egy olyan kivétel, amely összeomlasztja az alkalmazást.</answer>
        <answer>Ez egy másik neve a hibáknak.</answer>
        <correct>0</correct>
    </question>
    <question type="true_false">
        <text>A Throwable az összes kivételhez és hibához kapcsolódó osztály szülő osztálya.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Mi az összes kivétel szülő osztálya?</text>
        <correct>Exception</correct>
        <correct>java.lang.Exception</correct>
    </question>
    <question type="text">
        <text>Mi az összes nem ellenőrzött kivétel szülő osztálya?</text>
        <correct>RuntimeException</correct>
        <correct>java.lang.RuntimeException</correct>
    </question>
    <question type="true_false">
        <text>A hibákat mindig try-catch blokkokkal kell kezelni.</text>
        <correct>false</correct>
    </question>

    <!--
   <question type="single_choice">
       <text></text>
       <answer></answer>
       <answer></answer>
       <answer></answer>
       <answer></answer>
       <correct></correct>
   </question>

   <question type="multi_choice">
       <text></text>
       <answer></answer>
       <answer></answer>
       <answer></answer>
       <answer></answer>
       <correct></correct>
       <correct></correct>
   </question>

   <question type="true_false">
       <text></text>
       <correct></correct>
   </question>

   <question type="text">
       <text></text>
       <correct></correct>
       <correct></correct>
   </question>
   -->
</resources>
