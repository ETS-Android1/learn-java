<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!-- Exam of course 'Parallel programming' --><resources>
    <examdata>
        <id>25</id>
        <questionAmount>25</questionAmount>
        <timeLimit>30</timeLimit>
        <finished>true</finished>
    </examdata>

    <!-- Questions about basic parallel concepts. -->
    <question type="multi_choice">
        <text>Mi igaz a párhuzamos programokról?</text>
        <answer>Kizárólag Windows operációs rendszer alatt lehet őket futtatni.</answer>
        <answer>Ezek szekvenciális programok.</answer>
        <answer>Nem determinisztikusak.</answer>
        <answer>Ezek egyszerre több feladatot is képesek végrehajtani.</answer>
        <correct>2</correct>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Ezek közül melyik egy szál másik neve?</text>
        <answer>Runnable.</answer>
        <answer>Executor (futtató).</answer>
        <answer>Feladat.</answer>
        <answer>Nemdeterminizmus.</answer>
        <correct>2</correct>
    </question>
    <question type="single_choice">
        <text>Melyik a párhuzamos programozás ellentéte?</text>
        <answer>Szekvenciális.</answer>
        <answer>Konkurrens.</answer>
        <answer>Többszálas.</answer>
        <answer>Nemdeterminisztikus.</answer>
        <correct>0</correct>
    </question>
    <question type="multi_choice">
        <text>Melyek befolyásolhatják a párhuzamos alkalmazások hatékonyságát?</text>
        <answer>Az operációs rendszer.</answer>
        <answer>A hardver, pontosabban a CPU.</answer>
        <correct>0</correct>
        <correct>1</correct>
    </question>
    <question type="true_false">
        <text>A párhuzamos programok általában determinisztikusak.</text>
        <correct>false</correct>
    </question>
    <question type="true_false">
        <text>A szekvenciális programok általában determinisztikusak.</text>
        <correct>true</correct>
    </question>
    <question type="multi_choice">
        <text>Milyen előnyei vannak a párhuzamosságnak?</text>
        <answer>Növelheti a hatékonyságot.</answer>
        <answer>Egyszerű hibakeresés.</answer>
        <answer>A programok determinisztikusak lesznek.</answer>
        <answer>Hatékony GUI alkalmazások készítését teszi lehetővé.</answer>
        <correct>0</correct>
        <correct>3</correct>
    </question>
    <question type="multi_choice">
        <text>Milyen hátrányai vannak a párhuzamosságnak?</text>
        <answer>Az ilyen programokat nehezebb javítani.</answer>
        <answer>Nemdeterminizmus jön be a rendszerbe.</answer>
        <answer>Növekvő kód komplexitás.</answer>
        <answer>Semmi, nincs okunk arra, hogy ne használjuk.</answer>
        <correct>0</correct>
        <correct>2</correct>
    </question>
    <question type="single_choice">
        <text>Mi a nemdeterminizmus?</text>
        <answer>Egy másik szó a párhuzamos programozásra.</answer>
        <answer>Az azonos program különböző kimeneteket produkálhat, még azonos bemenet esetén is.</answer>
        <answer>A párhuzamos programok készítésének lehetősége Java-ban.</answer>
        <answer>Az azonos program mindig ugyanazt a kimenetet fogja produkálni, azonos bemenet esetén.</answer>
        <correct>1</correct>
    </question>

    <!-- Questions about the Thread class -->
    <question type="true_false">
        <text>Egy Java szálat csak egyszer lehet elindítani.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Melyik a szálak alaposztálya?</text>
        <correct>Thread</correct>
        <correct>java.lang.Thread</correct>
    </question>
    <question type="text">
        <text>Melyik osztályt használjuk arra, hogy futtatható utasításokat adjunk egy szálnak?</text>
        <correct>Runnable</correct>
        <correct>java.lang.Runnable</correct>
        <correct>Callable</correct>
        <correct>java.util.concurrent.Callable</correct>
    </question>
    <question type="true_false">
        <text>A szál objektumok a példányosításuk után azonnal elkezdik a végrehajtást.</text>
        <correct>false</correct>
    </question>
    <question type="single_choice">
        <text>Mi az anonim osztály?</text>
        <answer>Egy osztály, amelynek nincsenek alosztályai.</answer>
        <answer>Egy osztály, amelyet egy utasításban deklarálunk, nem pedig egy szabványos osztálydeklarációban.</answer>
        <answer>Egy osztály, amely csak statikus metódusokkal rendelkezik.</answer>
        <correct>1</correct>
    </question>
    <question type="multi_choice">
        <text>Milyen interfészeket használnak a végrehajtandó utasítások szálaknak való átadására?</text>
        <answer>java.lang.Runnable</answer>
        <answer>java.io.Serializable</answer>
        <answer>java.lang.Comparable</answer>
        <answer>java.util.concurrent.Callable</answer>
        <correct>0</correct>
        <correct>3</correct>
    </question>
    <question type="multi_choice">
        <text>Melyik módszert használhatjuk arra, hogy az utasításokat "átadjuk" egy szálnak?</text>
        <answer>Az anonim osztályos Runnable megvalósítást.</answer>
        <answer>Utasítások listájának létrehozása és átadása.</answer>
        <answer>A java.lang.Thread-ből származtatás.</answer>
        <answer>A java.lang.Runnable implementálása külön osztályban.</answer>.
        <correct>0</correct>
        <correct>2</correct>
        <correct>3</correct>
    </question>
    <question type="true_false">
        <text>A Thread osztályból nem tudunk alosztályt létrehozni.</text>
        <correct>false</correct>
    </question>

    <!-- Questions about basic Java parallel programming -->
    <question type="true_false">
        <text>A szálak végrehajtásának szüneteltetése megengedett.</text>
        <correct>true</correct>
    </question>
    <question type="single_choice">
        <text>Melyik kivételt kell kezelnünk, amikor szálakkal dolgozunk?</text>
        <answer>ArrayIndexOutOfBoundsException</answer>
        <answer>InterruptedException</answer>
        <answer>IOException</answer>
        <answer>RuntimeException</answer>
        <correct>1</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszóval deklarálhatunk egy olyan változót, amely mindig az aktuális értékét mutatja minden szálban (illékony)?</text>
        <correct>volatile</correct>
    </question>
    <question type="single_choice">
        <text>Mi a holtpont?</text>
        <answer>Amikor a program egy hiba miatt megszakad.</answer>
        <answer>Egy végtelen while ciklus.</answer>
        <answer>Amikor a szálak egymásra várnak, és így a program nem tud folytatódni.</answer>
        <answer>Amikor egy szál megszakad.</answer>
        <correct>2</correct>
    </question>
    <question type="multi_choice">
        <text>Melyik ezek közül a passzív várakozás?</text>
        <answer>Várakozás a join módszerrel.</answer>
        <answer>Várakozás egy ciklussal.</answer>
        <answer>Várakozás a wait metódussal.</answer>
        <answer>Holtponton ragadni.</answer>
        <correct>0</correct>
        <correct>2</correct>
    </question>
    <question type="single_choice">
        <text>Melyik metódussal szüneteltethetjük a szálak végrehajtását egy meghatározott időre?</text>
        <answer>sleep</answer>
        <answer>pause</answer>
        <answer>halt</answer>
        <answer>passiveWait</answer>
        <correct>0</correct>
    </question>
    <question type="true_false">
        <text>Az aktív várakozás előnyösebb mint a passzív várakozás.</text>
        <correct>false</correct>
    </question>
    <question type="single_choice">
        <text>Melyik metódus várakoztat egy szálat, amíg egy másik befejeződik?</text>
        <answer>wait</answer>
        <answer>sleep</answer>
        <answer>join</answer>
        <answer>interrupt</answer>
        <correct>2</correct>
    </question>
    <question type="true_false">
        <text>Ha le kell állítanunk egy szálat, akkor join-olhatjuk saját magával.</text>
        <correct>false</correct>
    </question>
    <question type="single_choice">
        <text>Mi a monitor?</text>
        <answer>Minden olyan objektum, amelynek várólistáját a wait és notify metódusokkal használjuk.</answer>
        <answer>Egy saját szál alosztály.</answer>
        <answer>Minden olyan objektum, amelyet egy szinkronizált blokk zárjaként használnak.</answer>
        <answer>Egy objektum, amelyet egy szinkronizált blokkon belül használnak.</answer>
        <correct>0</correct>
    </question>
    <question type="single_choice">
        <text>Mit csinál a 'wait' metódus?</text>
        <answer>Megállítja a szálat egy meghatározott ideig.</answer>
        <answer>A szál szünetet tart, amíg fel nem ébresztik egy 'notify' vagy 'notifyAll' hívással.</answer>
        <answer>Megszakítja a szálat.</answer>
        <correct>1</correct>
    </question>
    <question type="single_choice">
        <text>Melyik módszerrel lehet "felébreszteni" egyetlen szálat a monitorok várakozó sorában?</text>
        <answer>notify</answer>
        <answer>release</answer>
        <answer>wait</answer>
        <answer>notifyAll</answer>
        <correct>0</correct>
    </question>
    <question type="single_choice">
        <text>Melyik módszerrel "ébresztjük fel" az összes szálat a monitorok várakozó sorában?</text>
        <answer>notify</answer>
        <answer>release</answer>
        <answer>acquire</answer>
        <answer>notifyAll</answer>
        <correct>3</correct>
    </question>
    <question type="true_false">
        <text>A 'wait' és a 'notify' csak szinkronizált blokkban hívható.</text>
        <correct>true</correct>
    </question>

    <!-- Questions about mutual exclusion -->
    <question type="single_choice">
        <text>Mi a kölcsönös kizárás?</text>
        <answer>Amikor egy szálnak egy másik szál eredményére kell várnia.</answer>
        <answer>Amikor csak korlátozott számú szál hajthat végre kódrészleteket.</answer>
        <answer>Amikor több szál szünetel.</answer>
        <correct>1</correct>
    </question>
    <question type="true_false">
        <text>A Java beépített eszközökkel rendelkezik a kölcsönös kizárásra.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Melyik kulcsszóval lehet egy kódrészletet kölcsönösen kizáróvá tenni?</text>
        <correct>synchronized</correct>
    </question>
    <question type="multi_choice">
        <text>Melyik szinkronizálható?</text>
        <answer>Egy kódblokk.</answer>
        <answer>Egy osztály.</answer>
        <answer>Egy metódus.</answer>
        <answer>Egy adattag.</answer>
        <correct>0</correct>
        <correct>2</correct>
    </question>
    <question type="single_choice">
        <text>Mi a kritikus szakasz?</text>
        <answer>A kód, amelyet egy háttérszál hajt végre.</answer>
        <answer>Kód, amelyiknek van esélye InterruptedException-t dobni.</answer>
        <answer>Kód, amelyhez mindig legfeljebb egy meghatározott számú szálnak szabad hozzáférnie.</answer>
        <correct>2</correct>
    </question>
    <question type="true_false">
        <text>A szinkronizált blokk zárja figyeli, hogy van-e már szál a blokkon belül.</text>
        <correct>true</correct>
    </question>
    <question type="true_false">
        <text>A szinkronizált blokk zárja bármilyen objektum vagy primitív lehet.</text>
        <correct>false</correct>
    </question>
	<question type="true_false">
        <text>A szinkronizált blokk zárja bármilyen objektum lehet.</text>
        <correct>true</correct>
    </question>
    <question type="single_choice">
        <text>Mit használnak zárként, amikor egy nem statikus metódus szinkronizálódik?</text>
        <answer>A metódus visszatérési értéke.</answer>
        <answer>A metódus paramétere.</answer>
        <answer>Az objektum, amelyhez a metódus tartozik.</answer>
        <correct>2</correct>
    </question>
    <question type="single_choice">
        <text>Mi az a szemafor?</text>
        <answer>Egy objektum, amelynek várakozó sorát a wait és notify metódusokkal használjuk.</answer>
        <answer>Egy objektum, amelyet a szinkronizált blokk zárjaként használnak.</answer>
        <answer>Egy objektum, amely képes kölcsönös kizárást végrehajtani.</answer>
        <answer>Egy szál alosztály.</answer>
        <correct>2</correct>
    </question>
    <question type="multi_choice">
        <text>Milyen metódusokat használjuk a szemafor kritikus szakaszainak indítására és befejezésére?</text>
        <answer>acquire</answer>
        <answer>wait</answer>
        <answer>execute</answer>
        <answer>release</answer>
        <correct>0</correct>
        <correct>3</correct>
    </question>
    <question type="single_choice">
        <text>Mi az atomi művelet?</text>
        <answer>Egy olyan művelet, amely mentes mindenféle kivételtől.</answer>
        <answer>Egy művelet, amely többszálas környezetben is biztonságosan használható.</answer>
        <answer>A művelet, amelyet egy háttérszál végez.</answer>
        <correct>1</correct>
    </question>
    <question type="text">
        <text>Melyik osztály használható egy szálbiztos egész szám implementációhoz?</text>
        <correct>AtomicInteger</correct>
        <correct>java.util.concurrent.atomic.AtomicInteger</correct>
    </question>

    <!-- Questions about executor services -->
    <question type="single_choice">
        <text>Miért vezettek be egy új interfészt a Runnable helyett?</text>
        <answer>Mert a Runnable-nek nincsenek paraméterei.</answer>
        <answer>Mert a Runnable-ből nem lehet más metódusokat hívni.</answer>
        <answer>Mert a Runnable-nek nincs visszatérési értéke.</answer>
        <correct>2</correct>
    </question>
    <question type="text">
        <text>Mi a Runnable interfész modernebb alternatívája?</text>
        <correct>Callable</correct>
        <correct>java.util.concurrent.Callable</correct>
    </question>
    <question type="text">
        <text>Melyik osztály biztosít metódusokat a futtató szolgáltatások (executor service) létrehozásához?</text>
        <correct>Executors</correct>
        <correct>java.util.concurrent.Executors</correct>
    </question>
    <question type="single_choice">
        <text>Melyik az ideális, ha 100 azonos feladatot kell elvégezni a háttérben?</text>
        <answer>A Thread osztály.</answer>
        <answer>A fix szálas futtató szolgáltatás.</answer>
        <answer>Egy ütemezett futtató szolgáltatás.</answer>
        <answer>Egy egyszálas futtató szolgáltatás.</answer>
        <correct>1</correct>
    </question>
    <question type="true_false">
        <text>A futtató szolgáltatások addig várnak az új feladatokra, amíg kifejezetten le nem kapcsolják őket.</text>
        <correct>true</correct>
    </question>
    <question type="text">
        <text>Melyik osztály szolgál egy háttérfeladat enm biztos, hogy kiszámított értékének tárolására?</text>
        <correct>Future</correct>
        <correct>java.util.concurrent.Future</correct>
    </question>
    <question type="true_false">
        <text>A Future objektum get metódusának használata null-t ad vissza, ha a számítás még nem fejeződött be.</text>
        <correct>false</correct>
    </question>
    <question type="true_false">
        <text>A Future objektum get metódusának használata szünetelteti a szálat, ha a számítás még nem fejeződött be.</text>
        <correct>true</correct>
    </question>
    <question type="single_choice">
        <text>Mikor hatékonyabbak a futtató szolgáltatások, mint a szálak egyedi létrehozása?</text>
        <answer>Mikor a feladatok végrehajtási ideje rövid.</answer>
        <answer>Mikor a feladatok végrehajtási ideje hosszú.</answer>
        <answer>Mikor sok hasonló feladatot kell végrehajtani.</answer>
        <answer>Ha a feladatok valószínűleg kivételeket fognak dobni.</answer>
        <correct>2</correct>
    </question>

    <!--
    <question type="single_choice">
        <text></text>
        <answer></answer>
        <answer></answer>
        <answer></answer>
        <answer></answer>
        <correct></correct>
    </question>

    <question type="multi_choice">
        <text></text>
        <answer></answer>
        <answer></answer>
        <answer></answer>
        <answer></answer>
        <correct></correct>
        <correct></correct>
    </question>

    <question type="true_false">
        <text></text>
        <correct></correct>
    </question>

    <question type="text">
        <text></text>
        <correct></correct>
        <correct></correct>
    </question>
    -->
</resources>
