<?xml version="1.0" encoding="utf-8" standalone="no"?>
<resources>
    <taskdata>
        <id>250</id>
        <name>Tömb összegzése párhuzamosan</name>
    </taskdata>
    <text>
        <![CDATA[
        A feladatod egy hatalmas tömb létrehozása és az elemek összegzése, de szálakkal:
        ]]>
    </text>
    <list>
        <![CDATA[
        <ul>
        <li>Legyen a tömbben egymillió egész szám. Töltsük meg véletlenszerű számokkal, ehhez használjunk 1 és 10 közti számokat.</li>
        <li>Az összegzéshez használjunk <b>10</b> szálat (az eredmény tároláshoz egy <i>long</i>-ot ajánlok).</li>
        <li>Az összegzés a tömbön szekvenciálisan is elvégezhető. Ezt fogjuk használni az eredmény ellenőrzésére.</li>
        </ul>
        ]]>
    </list>
    <boxed title="Egyenletes eloszlás">
        <![CDATA[
        Minden szál ugyanannyi elemet összegezzen, azaz 1000-et.
        ]]>
    </boxed>
    <text>
        <![CDATA[
        Egy lehetséges módja annak, hogy véletlenszerű egész számokat kapjunk a 0 és 10 
		közötti tartományban:
        ]]>
    </text>
    <code><![CDATA[
        
<font color="#DF7401">int</font> randomNum = <font color="#999900">ThreadLocalRandom</font>.<font color="#ADD8E6">current</font>().<font color="#ADD8E6">nextInt</font>(<font color="#F0E130">0</font>, <font color="#F0E130">10</font>);
        
    ]]></code>
    <text>
        <![CDATA[
        Bármilyen megoldás használható a szálak létrehozására, de ne feledjük, hogy 10 alkalommal újrafelhasználásra kerülnek, 
		így egy jó választás a saját <i>Thread</i> alosztály készítése. Használhatsz egy 
		futtató szolgáltatást is <i>Callable</i>-kel párosítva!
        ]]>
    </text>
    <boxed title="Várakozás">
        <![CDATA[
         Bármilyen módszerrel biztosíthatod, hogy a főszál várjon a háttérfeladatok végére, 
		 én a <i>join</i>-os módszert ajánlom. Ha úgy döntöttél, hogy
         futtató szolgáltatást használsz, akkor a <i>Future.get</i> módszer a megoldás. 
		 A várakozás után az összegeket a szerezd meg szálakból, és számítsd ki a végső összeget.
        ]]>
    </boxed>
    <title text="Időmérés"/>
    <text>
        <![CDATA[
        A többszálú feldolgozás hatékonyságának demonstrálására mérjük meg a tömb párhuzamos összegzésének végrehajtási idejét. 
        Mérd meg a szekvenciális összegzés idejét is. Végül hasonlítsd össze az időbeli eredményeket.
        <p>
        Íme egy egyszerű módszer a végrehajtási idő mérésére:
        ]]>
    </text>
    <code><![CDATA[
        
<font color="#DF7401">long</font> start = <font color="#999900">System</font>.<font color="#ADD8E6">currentTimeMillis</font>();
<br/>
<br/><font color="gray">//write code here that needs to be measured</font>
<br/>
<br/><font color="#DF7401">long</font> end = <font color="#999900">System</font>.<font color="#ADD8E6">currentTimeMillis</font>();
<br/>
<br/><font color="gray">//this will be in milliseconds</font>
<br/><font color="#DF7401">long</font> executionTime = end - start;
        
    ]]></code>
    <text>
        <![CDATA[
        Hasonlítsd össze a párhuzamosan és szkevenciálisan kiszámított összegeket is, 
		és győződj meg arról, hogy azok megegyeznek.
        ]]>
    </text>
    <solution>
        <text>
            <![CDATA[
            Itt van az egyéni szál osztály. Megkapja az eredeti tömbre való hivatkozást, 
			valamint a kezdő- és végpozíciókat. Ezen pozíciók alapján tudja, hogy melyik a 
			tömbnek az a része, amit neki kell összegezni.
            ]]>
        </text>
        <code><![CDATA[
            
<font color="#E65100">public class</font> <font color="#999900">SumThread</font> <font color="#E65100">extends</font> <font color="#999900">Thread</font> {
<br/>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//Storing the sum here, only set after execution.</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">private</font> <font color="#DF7401">long</font> sum;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//The array which is summed. This is cut from the original array.</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">private final</font> <font color="#DF7401">int</font>[] numbers;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//the indices where we begin and end the summing</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">private final</font> <font color="#DF7401">int</font> beginIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">private final</font> <font color="#DF7401">int</font> endIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">public</font> <font color="#999900">SumThread</font>(<font color="#DF7401">int</font>[] numbers, <font color="#DF7401">int</font> beginIndex, <font color="#DF7401">int</font> endIndex) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">this</font>.<font color="#ADD8E6">numbers</font> = numbers;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">this</font>.<font color="#ADD8E6">beginIndex</font> = beginIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">this</font>.<font color="#ADD8E6">endIndex</font> = endIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">@Override</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">public</font> <font color="#DF7401">void</font> <font color="#ADD8E6">run</font>() {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#DF7401">int</font> i=beginIndex; i&lt;endIndex; i++) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;sum += numbers[i];
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//this must be called AFTER execution is done
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">public</font> <font color="#DF7401">long</font> <font color="#ADD8E6">getSum</font>() {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">return</font> sum;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>}
            
        ]]></code>
        <text>
            <![CDATA[
            A feladat előkészítéséhez és ellenőrzéséhez szükséges metódusok:
            ]]>
        </text>
        <code><![CDATA[
            
<font color="gray">//constants</font>
<br/><font color="#E65100">private static</font> <font color="#E65100">final</font> <font color="#DF7401">int</font> ARRAY_SIZE = <font color="#F0E130">1000000</font>;
<br/><font color="#E65100">private static</font> <font color="#E65100">final</font> <font color="#DF7401">int</font> THREAD_AMOUNT = <font color="#F0E130">10</font>;
<br/>
<br/><font color="gray">//method that creates an array of the given size
</font>
<br/><font color="#E65100">private static</font> <font color="#DF7401">int</font>[] <font color="#ADD8E6">createArray</font>() {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">int</font>[] numbers = <font color="#E65100">new</font> <font color="#DF7401">int</font>[ARRAY_SIZE];
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#DF7401">int</font> i=<font color="#F0E130">0</font>; i&lt;ARRAY_SIZE; i++) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;numbers[i] = <font color="#999900">ThreadLocalRandom</font>.<font color="#ADD8E6">current</font>().<font color="#ADD8E6">nextInt</font>(<font color="#F0E130">0,10</font>);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">return</font> numbers;
<br/>}
<br/>
<br/><font color="gray">//the method that does the summing sequentially
</font>
<br/><font color="#E65100">private static</font> <font color="#DF7401">long</font> <font color="#ADD8E6">sumSequential</font>(<font color="#DF7401">int</font>[] numbers) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> sum = <font color="#F0E130">0</font>;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#DF7401">int</font> number: numbers) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;sum += number;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">return</font> sum;
<br/>}
            
        ]]></code>
        <text>
            <![CDATA[
            Most a fontos rész következik: a párhuzamos összegzési metódusok. Itt van egy, amely az előbb látott saját szálat használja.
            ]]>
        </text>
        <code><![CDATA[
            
        <font color="gray">//the method that does the summing in parallel.
</font>
<br/><font color="#E65100">private static</font> <font color="#DF7401">long</font> <font color="#ADD8E6">sumParallel</font>(<font color="#DF7401">int</font>[] numbers) <font color="#E65100">throws</font> <font color="#999900">InterruptedException</font> {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//storing threads here to join on them later
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">SumThread</font>[] threads = <font color="#E65100">new</font> <font color="#999900">SumThread</font>[THREAD_AMOUNT];
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">final</font> <font color="#DF7401">int</font> THREAD_LOAD = ARRAY_SIZE / THREAD_AMOUNT;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//note that we increase iterator by 1000
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#DF7401">int</font> i=<font color="#F0E130">0</font>; i&lt;ARRAY_SIZE; i+=THREAD_LOAD) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//create a new thread and give it the indices
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">SumThread</font> thread = <font color="#E65100">new</font> <font color="#999900">SumThread</font>(numbers, i, i+T<font color="#999900">HREAD_LOAD</font>);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;threads[i/THREAD_LOAD] = thread;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;thread.<font color="#ADD8E6">start</font>(); <font color="gray">//start it
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//now we must wait for all threads to finish
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#999900">SumThread</font> thread: threads) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;thread.<font color="#ADD8E6">join</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//every thread finished, let's do the final summing
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> sum = <font color="#F0E130">0</font>;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#999900">SumThread</font> thread: threads) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;sum += thread.<font color="#ADD8E6">getSum</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">return</font> sum;
<br/>}
            
        ]]></code>
        <text>
            <![CDATA[
            Bemutatok egy olyan megoldást is, ami a futtató szolgáltatásokon alapul:
            ]]>
        </text>
        <code><![CDATA[
            
<font color="gray">//custom callable, very similar to the SumThread class</font>
<br/><font color="#E65100">static class</font> <font color="#999900">SumCallable</font> <font color="#E65100">implements</font> <font color="#999900">Callable</font>&lt;<font color="#999900">Long</font>> {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">private final</font> <font color="#DF7401">int</font>[] numbers;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">private final</font> <font color="#DF7401">int</font> beginIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">private final</font> <font color="#DF7401">int</font> endIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">public</font> <font color="#999900">SumCallable</font>(<font color="#DF7401">int</font>[] numbers, <font color="#DF7401">int</font> beginIndex, <font color="#DF7401">int</font> endIndex) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">this</font>.<font color="#ADD8E6">numbers</font> = numbers;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">this</font>.<font color="#ADD8E6">beginIndex</font> = beginIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">this</font>.<font color="#ADD8E6">endIndex</font> = endIndex;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">@Override</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">public</font> <font color="#999900">Long</font> <font color="#ADD8E6">call</font>() <font color="#E65100">throws</font> <font color="#999900">Exception</font> {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> sum = <font color="#F0E130">0</font>;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#DF7401">int</font> i=beginIndex; i&lt;endIndex; i++) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;sum += numbers[i];
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">return</font> sum;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/><font color="gray">//the method that does the summing in parallel.
</font>
<br/><font color="#E65100">private static</font> <font color="#DF7401">long</font> <font color="#ADD8E6">sumParallel</font>(<font color="#DF7401">int</font>[] numbers) <font color="#E65100">throws</font> ExecutionException, InterruptedException {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//create the tasks
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">List</font>&lt;<font color="#999900">SumCallable</font>> tasks = <font color="#E65100">new</font> <font color="#999900">ArrayList</font>&lt;>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">final</font> <font color="#DF7401">int</font> THREAD_LOAD = ARRAY_SIZE / THREAD_AMOUNT;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//note that we increase iterator by 1000
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#DF7401">int</font> i=<font color="#F0E130">0</font>; i&lt;ARRAY_SIZE; i+=THREAD_LOAD) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//create a new callable and give it the indices
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">SumCallable</font> task = <font color="#E65100">new</font> <font color="#999900">SumCallable</font>(numbers, i, i+T<font color="#999900">HREAD_LOAD</font>);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;tasks.<font color="#ADD8E6">add</font>(task);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//create the thread pool
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">ExecutorService</font> pool = <font color="#999900">Executors</font>.<font color="#ADD8E6">newFixedThreadPool</font>(THREAD_AMOUNT);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//give all tasks to the pool, and get futures back
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">List</font>&lt;<font color="#999900">Future</font>&lt;<font color="#999900">Long</font>>> futures = pool.<font color="#ADD8E6">invokeAll</font>(tasks);
<br/>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> sum = <font color="#F0E130">0</font>; <font color="gray">//wait for tasks to finish, and do the summing
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">for</font>(<font color="#999900">Future</font>&lt;<font color="#999900">Long</font>> future: futures) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;sum += future.<font color="#ADD8E6">get</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;pool.<font color="#ADD8E6">shutdown</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">return</font> sum;
<br/>}
            
        ]]></code>
        <text>
            <![CDATA[
            A főmtódusban létrehozzuk a tömböt, és kétszer végezzük el az összegzést, miközben mérjük az időt. Végül,
            az eredményeket összehasonlítjuk.
            <p>
            Vedd figyelembe, hogy ha futtató szolgáltatásokat használtunk, akkor a <i>main</i>-ben az <i>ExecutionException</i> fogására is szükség lesz.
            ]]>
        </text>
        <code><![CDATA[
            
<font color="#E65100">public</font> static <font color="#DF7401">void</font> <font color="#ADD8E6">main</font>(String[] args) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">int</font>[] numbers = <font color="#ADD8E6">createArray</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//calculate and measure sequential method
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> start = <font color="#999900">System</font>.<font color="#ADD8E6">currentTimeMillis</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> seqSum = <font color="#ADD8E6">sumSequential</font>(numbers);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> end = <font color="#999900">System</font>.<font color="#ADD8E6">currentTimeMillis</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> seqTime = end - start;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//calculate and measure the parallel method
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;start = <font color="#999900">System</font>.<font color="#ADD8E6">currentTimeMillis</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> parSum = <font color="#F0E130">0</font>;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#E65100">try</font> {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;parSum = <font color="#ADD8E6">sumParallel</font>(numbers);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;} <font color="#E65100">catch</font>(<font color="#999900">InterruptedException</font> e) {
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">System</font>.<font color="#ADD8E6">err</font>.<font color="#ADD8E6">println</font>(<font color="#2E8B57">"Interrupted, calculation invalid!"</font>);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;}
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;end = <font color="#999900">System</font>.<font color="#ADD8E6">currentTimeMillis</font>();
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#DF7401">long</font> parTime = end - start;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="gray">//compare the results:
</font>
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">System</font>.<font color="#ADD8E6">out</font>.<font color="#ADD8E6">println</font>(<font color="#2E8B57">"Sequential result: "</font> + seqSum);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">System</font>.<font color="#ADD8E6">out</font>.<font color="#ADD8E6">println</font>(<font color="#2E8B57"><font color="#2E8B57">"Parallel result: "</font></font> + parSum);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">System</font>.<font color="#ADD8E6">out</font>.<font color="#ADD8E6">println</font>(<font color="#2E8B57">"Sequential time: "</font> + seqTime + <font color="#2E8B57"><font color="#2E8B57">" milliseconds"</font></font>);
<br/>	&nbsp;&nbsp;&nbsp;&nbsp;<font color="#999900">System</font>.<font color="#ADD8E6">out</font>.<font color="#ADD8E6">println</font>(<font color="#2E8B57"><font color="#2E8B57">"Parallel result: "</font></font> + parTime + <font color="#2E8B57"><font color="#2E8B57">" milliseconds"</font></font>);
<br/>}
            
        ]]></code>
        <text>
            <![CDATA[
            Érdekes módon a szekvenciális összegzés gyorsabb, legalábbis az én számítógépemen. Ennek oka lehet, hogy
            időbe telik a szálak létrehozása és indítása, ami több időt vesz igénybe, mint a számok egyszerű összegzése.
            <p>
            Az eredmények egyeznek, tehát ez a művelet párhuzamosan is elvégezhető, de a végrehajtási idők
            azt jelzik, hogy ez nem optimális, itt inkább a szekvenciális a hatékonyabb.
            ]]>
        </text>
    </solution>
</resources>
